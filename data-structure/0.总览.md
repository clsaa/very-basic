# 0.总览

## 0.1.知识结构

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-27-913e0ababe43a2d57267df5c5f0832a7.jpg)

## 0.2.时间复杂度

假设有这么一段代码

```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是（2n+2) *unit_time。可以看出来，所有代码的执行时间 T(n）与每行代码的执行次数成正比。

尽管我们不知道 unit_ time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，所有代码的执行时间 T(n）与每行代码的执行次数n成正比。

T(n)=O(f(n))

T(n）表示代码执行的时间；n 表示数据规模的大小；f(n）表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n）来表示。公式中的O，表示代码的执行时间 T(n）与 f(n）表达式成正比。

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积