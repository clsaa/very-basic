# 数据库范式

## 0.基本概念

实体：现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。

属性：教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。

元组：表中的一行就是一个元组。

分量：元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。

码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。

全码：如果一个码包含了所有的属性，这个码就是全码。

主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。

非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。

外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。

函数依赖是一个关系内部属性与属性之间的一种约束条件.这种约束关系是通过属性间相关联系.它是现实世界属性间相互联系的抽象,是数据内在的性质,是语义的体现.
如Sname=f(Sno)即Sno函数决定Sname或Sname函数依赖于Sno
设R(U)是属性集U上的关系模式,X,Y是U的子集,对于R(U)的任意一个可能的关系R,R中不可能存在两个元组在X上的属性值相等,而在Y上的属性值不等.
X->Y,但Y不包含于X,则称X->Y是非平凡的函数依赖
X->Y,但Y包含于X,则称X->Y是平凡的函数依赖
在R(U)中,如果X->Y,并且对于X的任何一个真子集X',都有X'->Y,则称Y对X完全函数依赖.
设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。
R(U)中,如果X->Y(Y不包含于X),Y不能->X,Y->Z,Z不包含于Y,则称Z对X传递函数依赖.

## 1.第一范式

作为一个二维表,关系要符合一个最基本的条件:每一个分量必须是不可分的数据项.满足了这个条件的关系模式就属于第一范式(1NF).

在前面已经介绍了属性值的概念，我们说，它是“不可分的”。而第一范式要求属性也不可分。那么它和属性值不可分有什么区别呢？给一个例子：

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-183207.png)

这个表中，属性值“分”了。“电话”这个属性里对于“小明”属性值分成了两个。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-183225.png)


这两种情况都不满足第一范式。不满足第一范式的数据库，不是关系数据库！所以，我们在任何关系数据库管理系统中，做不出这样的“表”来。针对上述情况可以做成这样的表：这个表中，属性 “分”了。也就是“电话”分为了“手机”和“座机”两个属性。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-183254.png)


要求：每一个分量必须是不可分的数据项。

特点：

1. 有主键，且主键不能为空。
2. 字段不能再分。

示例：（以下例子不满足第一范式）

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-184313.png)

主键：学号

不满足原因：

1. 主键重复。
2. 信息字段可以再分


## 2.第二范式

符合1NF，并且，非主属性完全依赖于码。（注意是完全依赖不能是部分依赖，设有函数依赖W→A，若存在X和W，有X→A成立，那么称W→A是局部依赖，否则就称W→A是完全函数依赖）

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-183643.png)

一个学生上一门课，一定是特定某个老师教。所以有（学生，课程）－>老师；

一个学生上一门课，一定在特定某个教室。所以有（学生，课程）－>教室；

一个学生上一门课，他老师的职称可以确定。所以有（学生，课程）－>老师职称；

一个学生上一门课，一定是特定某个教材。所以有（学生，课程）－>教材

一个学生上一门课，一定在特定时间。所以有（学生，课程）－>上课时间

因此（学生，课程）是一个码。

然而，一个课程，一定指定了某个教材，一年级语文肯定用的是《小学语文1》，那么就有课程－>教材。（学生，课程）是个码，课程却决定了教材，这就叫做不完全依赖，或者说部分依赖。出现这样的情况，就不满足第二范式！

有什么不好吗？你可以想想：

1. 校长要新增加一门课程叫“微积分”，教材是《大学数学》，怎么办？学生还没选课，而学生又是主属性，主属性不能空，课程怎么记录呢，教材记到哪呢? ……郁闷了吧?(插入异常)
2. 下学期没学生学一年级语文（上）了，学一年级语文（下）去了，那么表中将不存在一年级语文（上），也就没了《小学语文1》。这时候，校长问：一年级语文（上）用的什么教材啊？……郁闷了吧?(删除异常)
3. 校长说：一年级语文（上）换教材，换成《大学语文》。有10000个学生选了这门课，改动好大啊！改累死了……郁闷了吧？（修改/更新异常，在这里你可能觉得直接把教材《小学语文1》替换成《大学语文》不就可以了，但是替换操作虽然计算机运行速度很快，但是毕竟也要替换10000次，造成了很大的时间开销）

那应该怎么解决呢？投影分解，将一个表分解成两个或若干个表

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-184510.png)


要求：在范式一的基础上，且每一个非主属性完全函数依赖于主键。

特点：

1. 满足第一范式。
2. 表中的每一个非主属性，必须完全依赖于本表主键。
3. 只有当一个表中，主键由两个或以上的属性组成的时候，才会出现不符合第二范式的情况。

示例：（以下例子不符合第二范式）

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-184624.png)

主键：学号，课程号
不满足原因：课程名不完全依赖于所定义的所有主键，课程名部分依赖于主键课程号。

再一个不符合要求的例子:

Sno=学生编号
Sdept=学生学院
Sloc=学院地址
Cno=课程编号
Grade=成绩

SLC(Sno,Sdept,Sloc,Cno,Grade)码为(Sno,Cno)其中有函数关系:

(Sno,Cno)-F->Ggrade
Sno->Sdept,(Sno,Cno)-P->Sdept
Sno->Sloc,(Sno,Cno)-P->Sloc
Sdept->Sloc

可以看到非主属性Sdept和Sloc并不完全函数依赖于码
分析可知,问题在于有两类非主属性,一类如Grade,它对码是完全函数依赖,另一类如Sdept,Sloc,它们对码不是完全函数依赖.解决方法是用投影把关系模式SLC分解为两个关系模式:SC(Sno,Cno,Grade)和SL(Sno,Sdept,Sloc)这样就满足第二范式了.


## 3.第三范式

符合2NF，并且，消除传递依赖（也就是每个非主属性都不传递依赖于候选键，判断传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。）

上面的“学生上课新表”符合2NF，但是它有传递依赖！在哪呢？问题就出在“老师”和“老师职称”这里。一个老师一定能确定一个老师职称。（学生，课程）->老师->职称。

有什么问题吗？想想：

1. 老师升级了，变教授了，要改数据库，表中有N条，改了N次……（修改异常）
2. 没人选这个老师的课了，老师的职称也没了记录……（删除异常）
3. 新来一个老师，还没分配教什么课，他的职称记到哪？……（插入异常）

应该怎么解决呢？和上面一样，投影分解：

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-27-184853.png)

在上述已经分解过的SC和SL中,SC没有传递依赖,而SL存在非主属性对码的传递依赖.Sno->Sdept,Sdept->Sloc,可得Sno-传递->Sloc.因此SC属于3NF而SL不属于第三范式.
>解决方法:SL分解为SD(Sno)和DL(Sdept,Sloc),分解后的SD和DL不再传递依赖.

## 4.BC范式

符合3NF，并且，主属性不依赖于主属性(也就是不存在任何字段对任一候选关键字段的传递函数依赖),不允许主键的一部分被另一部分或其它部分决定。BCNF消除了可能存在主属性对主码的部分及传递依赖。

BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。

还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。

给你举个例子：假设仓库管理关系表 (仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。

这个数据库表中存在如下决定关系：

(仓库ID, 存储物品ID) →(管理员ID, 数量)

(管理员ID, 存储物品ID) → (仓库ID, 数量)

所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：

(仓库ID) → (管理员ID)

(管理员ID) → (仓库ID)

即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。它会出现如下异常情况：

1. 删除异常：当仓库被清空后，所有"存储物品ID"和"数量"信息被删除的同时，"仓库ID"和"管理员ID"信息也被删除了。
2. 插入异常：当仓库没有存储任何物品时，无法给仓库分配管理员。
3. 更新异常：如果仓库换了管理员，则表中所有行的管理员ID都要修改。

把仓库管理关系表分解为二个关系表：

仓库管理：StorehouseManage(仓库ID, 管理员ID)；

仓库：Storehouse(仓库ID, 存储物品ID, 数量)。

这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。

一般，一个数据库设计符合3NF或BCNF就可以了。在BC范式以上还有第四范式、第五范式。

例子:关系模式STJ(S,T,J)中,S表示学生,T表示教师,J表示课程,每一个教师只教一门课,每门课有若干教师,某一学生选定某门课,就对应一个固定的教师,由语意可得如下函数依赖.(S,J)->T,(S,T)->J,T->J;在这里(S,J),(S,T)都是候选码.

STJ是3NF因为没有任何非主属性对码传递依赖或者部分依赖,但STJ不是BCNF关系,因为T是决定因素,而T不包含码.即T不是候选码.
3NF和BCNF是在函数依赖的条件下对模式分解所能打到的分离测度,一个模式中的关系模式如果都属于BCNF,那么在函数依赖范畴内它已经实现了彻底的分离,已消除了插入和删除的异常.3NF的不彻底性表现在可能存在主属性对码的部分依赖和传递依赖.

示例：（以下例子 不符合 第BCNF范式）

```
/*学生       老师        课程*/
  Stu      Teacher      Course
  张三       李开复       数据库
```
假设：每个老师只教一门课。

候选码：

(Stu,Teacher)->Course

(Stu,Course)->Teacher

这两个码由两个属性组成，而且它们是相互交叉的，所以不存在传递依赖，所以为3NF。

但是由于：Teacher->Course，（主键的一部分被另一部分决定,主属性对主码部分函数依赖），所以不符合BCNF。

关系模式SJP(S,J,P)中，S是学生，J表示课程，P表示名次，每一个学生选修每门课程的成绩都会有一定的名次，每门课程中每一个名次只有一个学生(即没有并列名次）。

函数依赖（S,J）决定P，（J,P）决定S;

所以（S,J）与（J,P）都可以作为候选码，这两个码由两个属性组成，不存在非主属性，显然没有非主属性对码的传递和部分函数依赖，所以SJP属于第三范式；而且满足上面1,2,3三条，所以SJP属于BCNF；


## 5.第四范式

要求把同一表内的多对多关系删除。

## 6.第五范式

从最终结构重新建立原始结构。

1NF->2NF:消除非主属性对码的部分函数依赖
2NF->3NF:消除非主属性对码的传递函数依赖
3NF->BCNF:消除主属性对码的部分和传递函数依赖
BCNF->4NF:消除非平反且非函数依赖的多值依赖.

这里主要区别3NF和BCNF，一句话就是3NF是要满足不存在非主属性对候选码的传递函数依赖，BCNF是要满足不存在任一属性（包含非主属性和主属性）对候选码的传递函数依赖。